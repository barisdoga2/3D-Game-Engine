package renderEngine;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import java.util.Map.Entry;

import org.lwjgl.opengl.GL11;
import org.lwjgl.opengl.GL30;
import org.lwjgl.util.vector.Matrix4f;
import org.lwjgl.util.vector.Vector3f;
import org.lwjgl.util.vector.Vector4f;

import engine.EngineSettings;
import entities.AnimatedEntity;
import entities.Camera;
import entities.Entity;
import entities.Light;
import entities.renderer.EntityRenderer;
import entities.renderer.NormalMapEntityRenderer;
import entities.renderer.animated.AnimatedEntityRenderer;
import models.TexturedModel;
import particles.InsertionSort;
import particles.Particle;
import particles.ParticleRenderer;
import particles.ParticleTexture;
import shadows.ShadowMapMasterRenderer;
import skybox.SkyboxRenderer;
import terrains.Terrain;
import terrains.TerrainRenderer;
import toolBox.Maths;
import uiSystem.UIRenderer;
import uiSystem.components.UIWindow;
import uiSystem.texts.UIText;
import uiSystem.textures.UITexture;
import waters.WaterFrameBuffer;
import waters.WaterRenderer;
import waters.WaterTile;

public class MasterRenderer{
	
	private static final Vector3f FOG_COLOR = new Vector3f(0.6588f, 0.6901f, 1f);
	private static final float FOG_DENSITY = 0.0035f;
	private static final float FOG_GRADIENT = 5.5f;
	
	private Matrix4f projectionMatrix;
	
	private Map<TexturedModel, List<Entity>> allEntities = new HashMap<TexturedModel, List<Entity>>();
	private EntityRenderer entityRenderer;
	
	private Map<TexturedModel, List<AnimatedEntity>> allAnimatedEntities = new HashMap<TexturedModel, List<AnimatedEntity>>();
	private AnimatedEntityRenderer animatedEntityRenderer;
	
	private Map<TexturedModel, List<Entity>> allNormalMappedEntities = new HashMap<TexturedModel, List<Entity>>();
	private NormalMapEntityRenderer normalMapEntityRenderer;
	
	protected List<Terrain> allTerrains = new ArrayList<Terrain>();
	private TerrainRenderer terrainRenderer;
	
	private List<WaterTile> allWaterTiles = new ArrayList<WaterTile>();
	private WaterFrameBuffer waterFrameBuffer;
	private WaterRenderer waterRenderer;
	
	private List<UIText> allUITexts = new ArrayList<UIText>();
	private List<UITexture> allUITextures = new ArrayList<UITexture>();
	private UIRenderer uiRenderer;
	
	private SkyboxRenderer skyboxRenderer;
	
	private Map<ParticleTexture, List<Particle>> allParticles = new HashMap<ParticleTexture, List<Particle>>();
	private ParticleRenderer particleRenderer;
	
	private ShadowMapMasterRenderer shadowMapMasterRenderer;
		
	public MasterRenderer(Camera camera){
		projectionMatrix = Maths.createProjectionMatrix();
		
		entityRenderer = new EntityRenderer(projectionMatrix);
		entityRenderer.loadFogConfig(FOG_COLOR, FOG_DENSITY, FOG_GRADIENT);
		
		animatedEntityRenderer = new AnimatedEntityRenderer(projectionMatrix);
		
		normalMapEntityRenderer = new NormalMapEntityRenderer(projectionMatrix);
		normalMapEntityRenderer.loadFogConfig(FOG_COLOR, FOG_DENSITY, FOG_GRADIENT);
		
		shadowMapMasterRenderer = new ShadowMapMasterRenderer(camera);
		terrainRenderer = new TerrainRenderer(projectionMatrix, shadowMapMasterRenderer);
		terrainRenderer.loadFogConfig(FOG_COLOR, FOG_DENSITY, FOG_GRADIENT);		
		
		uiRenderer = new UIRenderer();
		
		skyboxRenderer = new SkyboxRenderer(projectionMatrix);
		skyboxRenderer.loadFogColor(FOG_COLOR);
		
		waterFrameBuffer = new WaterFrameBuffer();
		waterRenderer = new WaterRenderer(projectionMatrix, waterFrameBuffer);
		waterRenderer.loadFogConfig(FOG_COLOR, FOG_DENSITY, FOG_GRADIENT);
		
		particleRenderer = new ParticleRenderer(projectionMatrix);
		
	}
	
	private void prepareRender(){
		enableBackFaceCulling();
		
		GL11.glEnable(GL11.GL_DEPTH_TEST);
		
		GL11.glClear(GL11.GL_COLOR_BUFFER_BIT | GL11.GL_DEPTH_BUFFER_BIT);
		GL11.glClearColor(FOG_COLOR.x, FOG_COLOR.y, FOG_COLOR.z, 1);
	}
	
	public void renderScene(Camera camera, List<Light> lights){
		this.renderScene(camera, lights, new Vector4f(0, 1, 0, 2147483647));
	}
	
	private void renderScene(Camera camera, List<Light> lights, Vector4f clippingPlane){
		prepareRender();
		
		entityRenderer.render(camera, lights, allEntities, clippingPlane);
		animatedEntityRenderer.render(camera, allAnimatedEntities);
		normalMapEntityRenderer.render(camera, lights, allNormalMappedEntities, clippingPlane);
		terrainRenderer.render(camera, lights, allTerrains, clippingPlane);
		
		if(EngineSettings.RENDER_SKYBOX)
			skyboxRenderer.render(camera);
	}
	
	public void renderShadowMap(Light sun){
		if(EngineSettings.SHADOWS_ON)
			shadowMapMasterRenderer.render(allEntities, allNormalMappedEntities, sun);
	}
	
	public void renderWaterEffects(Camera camera, List<Light> lights) { // -TODO- When Necessary - Implement Different Height Water Supply
		if(allWaterTiles.size() > 0){
			GL11.glEnable(GL30.GL_CLIP_DISTANCE0);
			
			float distanceToMoveCamera = camera.getPosition().y - WaterTile.WATER_HEIGHT;
			camera.getPosition().y -= distanceToMoveCamera * 2;
			camera.invertPitch();
			
			waterFrameBuffer.bindReflectionFrameBuffer();
			this.renderScene(camera, lights, new Vector4f(0, 1, 0, -WaterTile.WATER_HEIGHT + 1f));
			waterFrameBuffer.unbindCurrentFrameBuffer();
			
			camera.getPosition().y += distanceToMoveCamera * 2;
			camera.invertPitch();
			
			waterFrameBuffer.bindRefractionFrameBuffer();
			this.renderScene(camera, lights, new Vector4f(0, -1, 0, WaterTile.WATER_HEIGHT + 1f));
			waterFrameBuffer.unbindCurrentFrameBuffer();
			
			GL11.glDisable(GL30.GL_CLIP_DISTANCE0);
		}
	}
	
	public void renderWaterTiles(Camera camera, List<Light> lights){
		waterRenderer.renderWaters(camera, lights, allWaterTiles);
	}
	
	public void renderAndUpdateParticles(Camera camera){
		Iterator<Entry<ParticleTexture, List<Particle>>> hashMapIterator = allParticles.entrySet().iterator();
		
		while(hashMapIterator.hasNext()){
			List<Particle> list = hashMapIterator.next().getValue();
			
			Iterator<Particle> iterator = list.iterator();
			while(iterator.hasNext()){
				Particle particle = iterator.next();
				boolean isAlive = particle.update(camera);
				if(!isAlive){
					iterator.remove();
					if(list.isEmpty())
						hashMapIterator.remove();
				}
			}
			InsertionSort.sortHighToLow(list);
		}
		
		particleRenderer.render(camera, allParticles);
	}
	
	public void renderUIs(List<UIWindow> allUIWindows){
		uiRenderer.render(allUIWindows, allUITextures, allUITexts);
	}
	
	public static void enableBackFaceCulling(){
		GL11.glEnable(GL11.GL_CULL_FACE);
		GL11.glCullFace(GL11.GL_BACK);
	}
	
	public static void disableBackFaceCulling(){
		GL11.glDisable(GL11.GL_CULL_FACE);
	}

	public void cleanUp() {
		entityRenderer.cleanUp();
		animatedEntityRenderer.cleanUp();
		normalMapEntityRenderer.cleanUp();
		terrainRenderer.cleanUp();
		waterFrameBuffer.cleanUp();
		waterRenderer.cleanUp();
		uiRenderer.cleanUp();
		skyboxRenderer.cleanUp();
		particleRenderer.cleanUp();
		shadowMapMasterRenderer.cleanUp();
	}
	
	// ********************************************************************************************************************************** \\
	// ********************************************************* Add Methods ************************************************************ \\
	// ********************************************************************************************************************************** \\
	
	public void addUIText(List<UIText> uiTexts) {
		allUITexts.addAll(uiTexts);
	}

	public void addUITexture(List<UITexture> uiTextures) {
		allUITextures.addAll(uiTextures);
	}
	
	private void addNormalMappedEntity(Entity entity){
		List<Entity> batch = allNormalMappedEntities.get(entity.getTexturedModel());
		if(batch == null){
			batch = new ArrayList<Entity>();
			allNormalMappedEntities.put(entity.getTexturedModel(), batch);
		}
		
		batch.add(entity);
	}
	
	public void addEntity(Entity entity){
		if(entity.getTexturedModel().isUseNormalMap()){
			addNormalMappedEntity(entity);
		}else{
			List<Entity> batch = allEntities.get(entity.getTexturedModel());
			if(batch == null){
				batch = new ArrayList<Entity>();
				allEntities.put(entity.getTexturedModel(), batch);
			}
			batch.add(entity);
		}
	}
	
	public void addEntity(List<Entity> entityList){
		for(Entity e : entityList)
			addEntity(e);
	}
	
	public void addTerrain(Terrain terrain){
		allTerrains.add(terrain);
	}
	
	public void addTerrain(List<Terrain> terrains){
		allTerrains.addAll(terrains);
	}
	
	public void addWaterTile(WaterTile waterTile) {
		allWaterTiles.add(waterTile);
	}
	
	public void addWaterTile(List<WaterTile> waterTiles) {
		allWaterTiles.addAll(waterTiles);
	}
	
	public void addParticle(Particle particle){
		List<Particle> batch = allParticles.get(particle.getParticleTexture());
		if(batch == null){
			batch = new ArrayList<Particle>();
			allParticles.put(particle.getParticleTexture(), batch);
		}
		
		batch.add(particle);
	}

	public void addAnimatedEntity(AnimatedEntity animatedEntity) {
		List<AnimatedEntity> batch = allAnimatedEntities.get(animatedEntity.getTexturedModel());
		if(batch == null){
			batch = new ArrayList<AnimatedEntity>();
			allAnimatedEntities.put(animatedEntity.getTexturedModel(), batch);
		}
		batch.add(animatedEntity);
		
	}
	
	public void addAnimatedEntity(List<AnimatedEntity> animatedEntities) {
		for(AnimatedEntity animatedEntity : animatedEntities)
			addAnimatedEntity(animatedEntity);
	}
	
}
